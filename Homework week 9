387. 字符串中的第一个唯一字符
class Solution:
    def firstUniqChar(self, s: str) -> int:
        dic = {}
        for i in range(len(s)):
            if s[i] in dic:
                dic[s[i]][0] += 1
            else:
                dic[s[i]] = [1,i]
        
        for key,val in dic.items():
            if val[0] == 1:
                return val[1]
        
        return -1
        
36. 有效的数独
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        matrix_line = [set() for i in range(9)]
        matrix_column = [set() for i in range(9)]
        matrix_area = [set() for i in range(9)]
        for i in range(9):
            for j in range(9):
                item = board[i][j]
                pos = (i//3)*3 + j //3
                if item != '.':
                    if item not in matrix_line[i] and item not in matrix_column[j] and item not in matrix_area[pos]:
                        matrix_line[i].add(item)
                        matrix_column[j].add(item)
                        matrix_area[pos].add(item)
                    else:
                        return False
        return True
        
652. 寻找重复的子树
337. 打家劫舍 III
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        def calculate(node):
            if not node:
                return 0,0
            
            l_select, l_unselect = calculate(node.left)
            r_select, r_unselect = calculate(node.right)

            return node.val + l_unselect + r_unselect, max(l_select,l_unselect)+max(r_select, r_unselect)
        
        return max(calculate(root))
        
123. 买卖股票的最佳时机 III
(extra) 188. 买卖股票的最佳时机 IV
